import{e as p,s as c,a as b,u as s,g as w,c as U,T as g,b as h,d as I,W as T}from"./assets/supabaseClient-BGmU8szT.js";const D=6e4,C=1e4,B=1e3,M=6e4,y=12e4,W=3e5;let P=!1,S=!0;async function A(e){try{const{data:o,error:t}=await c.from("profiles").select("user_id").eq("user_id",e).single();return t?(console.error("Error getting profile user_id:",t),null):(o==null?void 0:o.user_id)||null}catch(o){return console.error("Error getting profile user_id:",o),null}}async function v(){try{const e=await chrome.windows.getAll({populate:!0});for(const t of e)if(t.focused&&t.tabs){for(const r of t.tabs)if(r.active&&r.url)return r.url}const o=await chrome.tabs.query({active:!0});return o.length>0&&o[0].url?o[0].url:null}catch{return null}}async function m(e){const o=await w();if(o.currentDomain===e)return;const t=U(o.currentDomain),r=U(e);o.currentDomain&&o.userId&&(t==="productive"&&o.consecutiveProductiveMs>=D?await L(o.currentDomain,o.consecutiveProductiveMs,o.userId):t==="unproductive"&&o.unproductiveMsBuffer>=C&&await O(o.unproductiveMsBuffer,o.userId));const n=t==="productive"&&r==="unproductive",i=t==="unproductive"&&r==="productive";await s({currentDomain:e,lastTick:Date.now(),consecutiveProductiveMs:n?0:o.consecutiveProductiveMs,unproductiveMsBuffer:i?0:o.unproductiveMsBuffer}),n?console.log("ðŸ”„ Switched from productive to unproductive domain, reset productive counter"):i?console.log("ðŸ”„ Switched from unproductive to productive domain, reset unproductive buffer"):t==="productive"&&r==="productive"&&console.log("âœ… Switched between productive domains, keeping productive counter running")}async function L(e,o,t){try{const r=Math.floor(o/1e3);await c.from("productive_triggers").insert({user_id:t,domain:e,duration_seconds:r}),console.log(`Recorded productive trigger: ${e} for ${r}s`)}catch(r){console.error("Error recording productive trigger:",r)}}async function O(e,o){try{const t=Math.floor(e/1e3);await c.from("leaderboard_scores").insert({user_id:o,score:t}),console.log(`Recorded unproductive time: ${t}s`)}catch(t){console.error("Error recording unproductive time:",t)}}async function $(){try{const e=await w(),o=Date.now();if(e.lastCallTriggerTime>0&&o-e.lastCallTriggerTime<W){console.log("AI call cooldown active, skipping call");return}if(!e.userId){console.error("No user ID found. Cannot initiate call.");return}const{data:t,error:r}=await c.from("profiles").select("dads_number").eq("user_id",e.userId).single();if(r||!t){console.error("Error fetching profile:",r);return}const n=t.dads_number;if(!n||!n.trim()){console.error("Dad's number not found in profile. Cannot initiate call.");return}const i=n.trim().replace(/[\s\-\(\)]/g,""),a=i.startsWith("+")?i:i.startsWith("1")&&i.length===11?`+${i}`:`+1${i}`;if(console.log("Calling dad's number:",a,"(original:",n,")"),!T||T.includes("your-webhook-server.com")){console.error("Webhook URL not configured. Please set VITE_WEBHOOK_URL in .env file.");return}const d=btoa(`${g}:${h}`),u=`https://api.twilio.com/2010-04-01/Accounts/${g}/Calls.json`,f=new URLSearchParams;f.append("From",I),f.append("To",a),f.append("Url",T),f.append("Method","POST"),console.log("Twilio API Request:",{url:u,accountSid:g?`${g.substring(0,10)}...`:"MISSING",authToken:h?`${h.substring(0,10)}...`:"MISSING",from:I,to:a,webhook:T});const l=await fetch(u,{method:"POST",headers:{Authorization:`Basic ${d}`,"Content-Type":"application/x-www-form-urlencoded"},body:f.toString()});if(!l.ok){const _=await l.text();console.error("Twilio API Error:",{status:l.status,statusText:l.statusText,error:_.substring(0,500)}),l.status===401||l.status===403?console.error("Twilio authentication failed. Please check your Twilio credentials in the .env file and rebuild the extension."):(_.includes("html")||_.includes("login"))&&console.error("Twilio authentication failed. The credentials may be incorrect. Please verify your Twilio Account SID and Auth Token.");return}const N=await l.json();console.log("âœ… AI agent call successfully initiated!"),console.log("   Call SID:",N.sid),console.log("   To:",a),await s({lastCallTriggerTime:o,consecutiveProductiveMs:0,totalProductiveMs:0}),console.log("âœ… Productive time reset to 0 after call initiation"),console.log("   Counter will start accumulating again for the next cycle")}catch(e){console.error("âŒ Error triggering AI call:",e),e instanceof Error&&console.error("   Error message:",e.message)}}async function x(e,o){try{const{data:t,error:r}=await c.from("profiles").select("user_id").eq("user_id",e).single();if(r||!t){console.error("Profile not found for user_id:",e,r);return}const n=Math.floor(o/1e3),{error:i}=await c.from("leaderboard_global").upsert({user_id:e,best_score:n,updated_at:new Date().toISOString()},{onConflict:"user_id"});i?console.error("Error updating leaderboard_global:",{message:i.message,details:i.details,hint:i.hint,code:i.code,userId:e,best_score:n}):console.log(`Updated leaderboard_global: ${n}s unproductive time (best_score) for user ${e}`)}catch(t){console.error("Error updating leaderboard_global:",t instanceof Error?t.message:String(t))}}async function E(){const e=await w(),o=Date.now(),t=o-e.lastTick,r=1e4,n=t>r?r:t;if(n<=0){await s({lastTick:o});return}if(t>r&&console.log(`âš ï¸ Service worker was suspended for ${Math.floor(t/1e3)}s, continuing tracking with capped elapsed time`),P&&!S){console.log("â¸ï¸ Pausing tracking: user is idle and window is not focused"),await s({lastTick:o});return}const a=await v(),d=p(a??void 0);if(d!==e.currentDomain){await m(d);const u=await w();await k(u,n)}else await k(e,n)}async function k(e,o){const t=U(e.currentDomain),r=e.userId;if(!r||!e.currentDomain){await s({lastTick:Date.now()});return}if(t==="productive"){const n=e.consecutiveProductiveMs+o,i=(e.totalProductiveMs||0)+o,a=e.consecutiveProductiveMs;if(n>=y&&a<y){const u=Math.floor(n/1e3);console.log(`âœ… Productive time reached ${u} seconds (2 minutes), triggering AI agent call`),await $()}n>=D&&a<D&&await L(e.currentDomain,n,r),await s({consecutiveProductiveMs:n,totalProductiveMs:i,lastTick:Date.now()})}else if(t==="unproductive"){const n=e.unproductiveMsBuffer+o,i=(e.totalUnproductiveMs||0)+o;n>=C?(await O(n,r),await s({unproductiveMsBuffer:0,totalUnproductiveMs:i,lastTick:Date.now()})):await s({unproductiveMsBuffer:n,totalUnproductiveMs:i,lastTick:Date.now()})}else await s({lastTick:Date.now()})}async function R(){const e=await w(),o=Date.now();if(!e.userId)return;o-(e.lastLeaderboardUpdate||0)>=M&&(await x(e.userId,e.totalUnproductiveMs||0),await s({lastLeaderboardUpdate:o}))}async function G(){const{data:{session:e}}=await c.auth.getSession();if(e!=null&&e.user){const r=await A(e.user.id);r?(await b(r),console.log("Restored session for user:",e.user.email)):console.warn("Profile not found for auth user, cannot set userId")}const o=await v(),t=p(o??void 0);await m(t),setInterval(()=>{E().catch(r=>{console.error("Error in tick:",r)})},B),chrome.alarms.create("leaderboardUpdate",{periodInMinutes:M/6e4,delayInMinutes:M/6e4}),E().catch(console.error),R().catch(console.error),console.log("âœ… Tracking initialized"),console.log("   - Counter will continue even when window loses focus"),console.log("   - Counter only pauses if user is idle AND window is not focused"),console.log("   - Service worker suspension is handled automatically")}chrome.alarms.onAlarm.addListener(e=>{e.name==="leaderboardUpdate"&&R().catch(console.error)});chrome.tabs.onActivated.addListener(async()=>{const e=await v(),o=p(e??void 0);await m(o)});chrome.tabs.onUpdated.addListener(async(e,o,t)=>{if(o.status==="complete"&&t.url){const r=p(t.url);await v()===t.url&&await m(r)}});chrome.windows.onFocusChanged.addListener(async e=>{if(e===chrome.windows.WINDOW_ID_NONE)S=!1,console.log("âš ï¸ Window lost focus, but tracking continues (counter will NOT stop)");else{S=!0,console.log("âœ… Window gained focus, tracking active");const o=await v(),t=p(o??void 0);await m(t)}});chrome.idle.onStateChanged.addListener(e=>{P=e==="idle"||e==="locked",console.log(P?"âš ï¸ User is idle/locked, but tracking continues (counter will only pause if window is also not focused)":"âœ… User is active, tracking continues")});c.auth.onAuthStateChange(async(e,o)=>{if(e==="SIGNED_IN"&&(o!=null&&o.user)){const t=await A(o.user.id);t?(await b(t),console.log("User signed in:",o.user.email)):console.warn("Profile not found for auth user, cannot set userId")}else e==="SIGNED_OUT"&&(await b(null),await s({currentDomain:null,consecutiveProductiveMs:0,unproductiveMsBuffer:0,totalProductiveMs:0,totalUnproductiveMs:0,lastLeaderboardUpdate:0,lastCallTriggerTime:0}),console.log("User signed out"))});G().catch(console.error);
